---
title: "App Router 3"
description: "Next.js의 pageRouter와 ApppRouter의 렌더링 방식을 비교하며 어떤 점이 달라졌는지 살펴봅니다."
thumbnail: "/assets/blog/app-router/cover.png"
tags: ["Next.js"]
createdAt: "2024년 09월 06일"
category: "DEV"
---

https://www.inflearn.com/course/%ED%95%9C%EC%9E%85-%ED%81%AC%EA%B8%B0-nextjs/dashboard

인프런의 한 입 크기로 잘라먹는 Next.js 강의를 듣고 정리한 내용입니다.

---

## Request Memoization

![{Request Memoization의 캐싱 과정](/assets/blog/app-router/11.png)

하나의 페이지를 이루고 있는 여러 컴포넌트에서 중복으로 발생한 요청을 캐싱해서 한 번만 요청하도록 자동으로 데이터 패칭을 최적화해주는 기능입니다.

접속 요청을 받은 페이지에 동일한 주소의 동일한 데이터를 불러오는 데이터 패칭 요청이 있고 캐싱 옵션이 `no-store`로 되어 있을 경우 리퀘스트 메모이제이션이 자동으로 캐싱하여 한 번만 요청하여 캐싱합니다.

주의할 점은 리퀘스트 메모이제이션은 하나의 페이지를 요청하는 동안에만 존재하는 캐시로서 중복되는 API 요청을 방지하는 데에만 목적을 두고 있습니다.
따라서 렌더링이 종료되면 캐시가 소멸되어 다음 접속 요청에는 데이터를 다시 요청하기 때문에 데이터 캐시와는 다릅니다.

Next가 리퀘스트 메모이제이션을 제공하는 이유는 서버 컴포넌트가 도입되면서 컴포넌트가 각각 필요한 데이터를 직접 패칭하는 방식으로 데이터 패칭이 진행됩니다.
컴포넌트가 직접 패칭하기 때문에 컴포넌트 구조가 복잡해져도 독립적인으로 사용할 수 있습니다.
하지만 이런 패턴을 사용하다보니 다른 컴포넌트에서 동일한 데이터를 필요로 하는 예외적인 경우가 발생합니다.

## Full Route Cache

![{Full Route Cache의 캐싱 과정](/assets/blog/app-router/12.png)

`/a`페이지가 풀 라우트 캐시에 저장되는 페이지로 설정되었다면 빌드 타임에 렌더링을 진행합니다.
페이지에 필요한 데이터를 리퀘스트 메모이제이션이나 데이터 캐시 등의 캐싱 기능을 거쳐서 렌더링이 완료된 결과를 풀 라우트 캐시라는 이름으로 서버 측에 저장합니다.

빌드 타임 이후에 `/a` 페이지로 접속 요청이 들어오면 캐시가 `HIT`되어서 브라우저에 전송하여 빠른 속도로 처리합니다.

풀 라우트 캐시는 SSG 방식과 유사하게 빌드 타임에 정적으로 페이지를 만들어 놓고 캐시에 보관한 다음에 브라우저에서 요청이 오면 캐시에 저장된 페이지를 응답하는 페이지 캐싱 기능입니다.

Next 앱에 만든 모든 페이지는 자동으로 정적 페이지(Static Page)와 동적 페이지(Dynamic Page)로 나뉘고 정적 페이지에만 풀 라우트 캐시가 적용됩니다.

동적 페이지로 구분되는 경우

-
