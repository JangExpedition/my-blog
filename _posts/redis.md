---
title: "Redis 구축"
description: "1초에 10번씩 들어오는 데이터가 DB에 업데이트 되는 속도보다 빨라서 발생한 문제를 Redis를 통해 해결한 과정을 적었습니다."
thumbnail: "/assets/blog/redis/cover.png"
tags: ["Troubleshooting"]
createdAt: "2024-07-13 10:00:00"
category: "DEV"
---

## 개요

환기 장비에서 보내는 데이터를 실시간으로 DB에 업데이트를 하여 장비를 제어하고 모니터링하는 웹 페이지를 만들었습니다.
먼저 다음과 같은 요구 사항이 있었습니다.

- MQTT 통신으로 장비와 데이터를 주고 받습니다. (고객사에서 데이터 통신비가 부담된다고 하여 MQTT 통신으로 제안을 드렸습니다. MQTT 통신은 HTTP보다 패킷이 적어 데이터 통신비를 아낄 수 있습니다.)
- 한 시간에 한 번씩 데이터를 저장하여 누적 데이터를 기록합니다.

## 기존 로직

1. MQTT 통신으로 장비의 정보를 받습니다.
2. 받은 정보를 바탕으로 다른 데이터와 결합하여 DB에 저장합니다.
3. 브라우저에서 DB로 비동기 요청을 보내 DB에 업데이트된 내용을 실시간으로 사용자에게 보여줍니다.
4. 정각마다 장비 데이터 DB를 조회하여 업데이트 시간이 한 시간이 넘었을 경우 값을 모두 0으로, 넘지 않았을 경우 값을 그대로 누적 데이터 테이블에 저장했습니다.

기존 로직으로 다섯 대의 장비에서 60초에 한 번씩 데이터를 보내는 테스트를 했을 때는 정상 동작했습니다.

## 문제 발생

양산을 앞둔 상황에서 장비 두 대에서 1초에 다섯 번씩 데이터를 보냈습니다.
장비를 직접 제어했을 때 제어한 내용이 브라우저 화면에 반영되지 않았습니다.
웹 페이지에서 제어했을 때도 장비는 제어가 됐지만 브라우저에서 확인할 수 없었습니다.

원인을 분석해보니 장비에서 데이터를 보내는 시간이 DB에 업데이트 되는 시간보다 빨랐습니다.
이로 인해 장비에서는 이미 데이터를 보냈으나 DB에 업데이트 되지않아 브라우저에서 실시간 정보를 확인할 수 없었습니다.
테이블 회전이 느린 음식집에 손님이 몰리는 경우를 생각하면 좋을 것 같습니다.

해결 방안으로 데이터 처리 속도를 늘리거나 데이터를 병렬로 받는 방법이 생각났습니다.

## 1. 해결 시도 - 병렬 처리

처음 시도한 방법은 병렬 처리였습니다.
지금 음식점에서는 들어오는 손님의 숫자를 감당하지 못 하니 옆에 2호점을 만들어서 분산을 시키는 것이죠.

병렬 처리는 어떻게 하는지 열심히 구글링하였더니 메세지 큐를 사용한다고 나왔습니다.
메세지 큐 기반으로 가장 대중적인 것이 Kafka라고 판단하고 Kafka에 대해서 얕고 빠르게 알아봤습니다.

Kafka는 크게 프로듀서, 브로커, 컨슈머로 구분됩니다.
병렬 처리를 위해서 여러 브로커를 만드는 방법과 하나의 브로커에서 파티션을 나누는 방법이 있습니다.
여러 브로커를 만드는 방법은 로직이 구분되어야 하는 데 현 상황에서는 데이터를 받아서 업데이트만 하기 때문에 적합하지 않다고 판단했습니다.
하나의 브로커에 파티션을 나누는 방법은 순서 보장이 되지 않아서 적합하지 않다고 생각했습니다.
실시간으로 장비의 상태를 보여줘야 하는데 순서가 보장되지 않으면 사용자가 브라우저에 보이는 데이터를 신뢰할 수 없다고 생각했습니다.

## 2. 해결 시도 - 소켓 통신으로 데이터 뿌려주기

두 번째로 시도한 방법은 MQTT 메세지로 받은 데이터를 테이블에 저장하지 않고 소켓 통신으로 직접 브라우저로 전송하는 방법입니다.

장비마다 고유의 MQTT 토픽 주소를 갖고 사용자가 조회한 장비에 대해서만 구독하여 들어온 데이터를 기타 데이터와 결합하여 소켓 통신으로 브라우저에게 날려주면 해결할 수 있다고 생각했습니다.
DB는 데이터가 실시간으로 변하니 누적 데이터가 아니면 굳이 저장할 필요가 없었습니다.

로직을 수정했더니 실시간 데이터는 잘 반영되었습니다.
이대로 해결되는 줄 알았지만 추가로 문제가 발생했습니다.

정각마다 누적 데이터를 저장할 때 모든 장비의 현재 상태를 저장해야 합니다.
하지만 장비마다 데이터를 보내는 시간을 조정할 수 있고 정각을 기준으로 5분 내외로 들어온 데이터를 저장한다고 하면 20분 간격으로 데이터를 보내는 장비는 매번 저장되지 않을 것입니다.
또한 1시간 내에 데이터를 보내지 않은 장비는 값을 0으로 저장해야 하는데 데이터를 저장하지 않으니 언제 마지막으로 어떤 데이터를 보냈는지 확인할 수 없었습니다.

## 해결 - Redis 사용하기

다시 한 번 테이블 회전 수를 늘리는 방향으로 생각했습니다.
좀 더 빠르게 데이터를 저장할 수 있는 방법이 없을까?
자료를 찾던 중 NoSQL에 대해서 알게 되었고 기존 DB를 MongoDB로 바꿔야하나 고민했습니다.
하지만 Redis를 사용하면 기존의 DB는 그대로 사용하면서 장비 데이터만 NoSQL을 사용하여 저장할 수 있었습니다.

다시 한 번 얕고 빠르게 Redis에 대해서 알아봤습니다.
여러 데이터 타입을 지원하는 데 List가 적합하다고 판단했습니다.
또한 정각마다 Redis의 최신 값을 가져와서 DB에 저장할 때 전체 삭제를 하여 메모리에 데이터가 지속적으로 쌓이지 않도록 방지했습니다.

Redis 서버 구축은 서버 컴퓨터에 Redis 도커 이미지로 컨테이너를 구축하고 docker network를 생성하여 프로젝트 컨테이너와 연결만 해줬더니 데이터가 저장되었습니다.
