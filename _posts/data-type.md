---
title: "데이터 타입 (Data Type)"
description: "기본형과 참조형 데이터가 컴퓨터 메모리에 어떤 방식으로 저장되는지 자세하게 설명합니다."
thumbnail: "/assets/blog/data-type/cover.png"
tags: ["JavaScript"]
createdAt: "2024-08-01 10:00:00"
category: "DEV"
---

https://www.inflearn.com/course/%ED%95%B5%EC%8B%AC%EA%B0%9C%EB%85%90-javascript-flow#

인프런의 코어 자바스크립트 강의를 듣고 정리한 내용입니다.

---

# 메모리 동작 방식

![JavaScript의 데이터 타입](/assets/blog/data-type/1.png)

자바스크립트의 메모리 구조는 스택 메모리와 힙 메모리 영역으로 나뉘어 있다.
스택 메모리에는 변수와 함께 기본형 데이터가 저장되고 힙 메모리에는 참조형 데이터가 저장된다.
하지만 이 강의에서는 스택과 힙에 대해서 깊게 파진 구조에 대해서 최대한 단순화 시켜서 흐름을 파악하게끔 설명해주신다고 한다.

## 기본형

> - Number
> - String
> - Boolean
> - null
> - undefined
> - Symbol(ES6)

```js
var a;
```

위와 같이 변수 a를 선언합니다.
컴퓨터는 메모리 안에서 데이터가 담길 공간을 미리 확보 합니다.

![컴퓨터 메모리 이미지 1](/assets/blog/data-type/2.png)

```js
a = "abc";
```

이후 a에 'abc' 값을 할당합니다.
컴퓨터는 비어있는 다른 메모리 공간에 값을 저장합니다.

![컴퓨터 메모리 이미지 2](/assets/blog/data-type/3.png)

컴퓨터는 주소를 든 채로 변수 a가 가르키는 주소로 이동합니다.
변수 a가 어디있는지 모르지만 값이 들어있는 공간을 검색하다가 이름이 식별자 a로 되어 있는 메모리를 찾아서 값에 주소를 넣어줍니다.

![컴퓨터 메모리 이미지 3](/assets/blog/data-type/4.png)

이후에 같은 변수 a에 'abcdef' 값을 넣습니다.
컴퓨터는 기존 주소에 값을 바꾸는 대신에 다른 공간에 'abcdef'를 넣고 그 주소를 다시 a의 값으로 넣어줍니다.

![컴퓨터 메모리 이미지 4](/assets/blog/data-type/5.png)

기본형에서 값이 변하면 가르키고 있는 값을 직접 바꿉니다.

## 참조형

> - Object
>   - Array
>   - Function
>   - RegExp
>   - Set / WeakSet (ES6)
>   - Map / WeakMap (ES6)

```js
var obj = {
  a: 1,
  b: "bbb",
};
```

참조형 데이터는 동작이 좀 더 복잡합니다.
변수를 선언하고 할당하는 것은 동일합니다.
위 코드를 컴퓨터가 이해하는 방식대로 바꿔보면

```js
var obj;
obj = {
  a: 1,
  b: "bbb",
};
```

위 코드와 같습니다.
선언이 먼저 이뤄지고 그 다음에 할당이 이뤄집니다.
즉 선언과 할당을 동시에 써놔도 선언 이후에 할당으로 나눠 처리합니다.

![컴퓨터 메모리 이미지 5](/assets/blog/data-type/6.png)

먼저 메모리의 빈 공간의 이름을 obj로 선언합니다.
다음에 값을 할당해야 하는데 메모리 공간에는 값이 하나밖에 들어가지 못합니다.
하지만 객체 안에 프로퍼티가 있고 프로퍼티에 값이 하나씩 두 개의 데이터가 필요한 상황입니다.

![컴퓨터 메모리 이미지 6](/assets/blog/data-type/7.png)

먼저 한 메모리에서 여러 메모리를 확보합니다.
확보한 메모리에 해당 객체의 프로퍼티를 지정합니다.

![컴퓨터 메모리 이미지 7](/assets/blog/data-type/8.png)

프로퍼티에 대한 선언과 할당 방식은 기본형과 같습니다.
한 메모리의 이름에 a를 선언하고 비어있는 메모리를 확보해 값을 넣습니다.
값의 주소를 들고 a의 값에 할당합니다.
b도 동일하게 하나의 메모리에 b라는 이름을 선언하고 비어있는 메모리에 "bbb"를 넣은 뒤 b의 값으로 주소를 할당합니다.

![컴퓨터 메모리 이미지 8](/assets/blog/data-type/9.png)

객체 안에 프로퍼티가 모두 할당 되었으므로 여러 주소를 갖고 있는 메모리의 주소를 들고 obj의 값으로 할당합니다.
즉 참조형은 기본형보다 한 단계 더 거치게 됩니다.

```js
obj.a = 2;
```

이후에 obj.a의 값을 2로 바꿉니다.

![컴퓨터 메모리 이미지 9](/assets/blog/data-type/10.png)

먼저 2라는 값을 갖고 있는 메모리가 없으니, 빈 메모리에 2라는 값을 할당합니다.
해당 메모리의 주소를 든 채로 obj.a를 찾습니다.
obj에 할당된 주소를 찾고 값으로 할당된 주소로 이동한 다음 a 프로퍼티를 찾아서 값을 바꿔줍니다.

![컴퓨터 메모리 이미지 10](/assets/blog/data-type/11.png)

obj.a 값은 변경되었으나 obj의 값은 그대롭니다.
객체에 있는 프로퍼티의 값을 바꾸면 obj.a의 값은 바뀌지만 obj의 값은 변하지 않습니다.

## 중첩 객체

```js
var obj = {
  x: 3,
  arr: [3, 4],
};
```

![컴퓨터 메모리 이미지 11](/assets/blog/data-type/12.png)

obj.x는 참조형에서 설명드린 방식과 동일합니다.

![컴퓨터 메모리 이미지 12](/assets/blog/data-type/13.png)

배열은 참조형 데이터이므로 여러 메모리를 확보합니다.
확보한 메모리에 인덱스 0을 선언합니다.
arr[0]의 값 3은 이미 메모리에 저장된 값입니다.
3이 저장된 메모리 주소를 0에 할당합니다.
arr[1]은 값이 4이므로 빈 메모리에 4를 할당하고 해당 주소를 값으로 지정합니다.

![컴퓨터 메모리 이미지 13](/assets/blog/data-type/14.png)

배열에 대한 저장이 완료됐으니 해당 주소를 arr의 값으로 할당합니다.
동시에 객체에 대한 할당도 완료됐습니다.

```js
obj.arr = "str";
```

obj.arr에 문자열 "str"를 할당하면 어떻게 될까요?

![컴퓨터 메모리 이미지 14](/assets/blog/data-type/15.png)

먼저 "str" 값을 가진 메모리가 없으니 빈 메모리에 할당하고 해당 주소를 obj가 가르키는 주소로 이동한 다음 값이 가르키는 주소의 메모리로 이동하여 프로퍼티로 지정한 주소로 다시 이동하고 arr의 값을 바꿔줍니다.

## Garbage Collector

![컴퓨터 메모리 이미지 15](/assets/blog/data-type/16.png)

그러면 해당 배열을 담고 있는 메모리는 어떻게 될까요?
해당 배열을 참조하고 있는 대상이 없습니다.
이를 참조 카운트가 0이라고 표현합니다.
참조 카운트란 참조하고 있는 대상의 갯수입니다.
참조 카운트가 0인 메모리는 Garbage Collector의 수거 대상입니다.

![컴퓨터 메모리 이미지 16](/assets/blog/data-type/17.png)

배열을 담고 있는 메모리가 사라짐으로써 배열을 참조하고 있는 메모리들도 Garbage Collector에 의해 같이 수거됩니다.

![컴퓨터 메모리 이미지 17](/assets/blog/data-type/18.png)

'만약 x와 arr[0]가 값이 3으로 동일하니까 메모리 값으로 주소가 아닌 직접 3을 넣으면 하나의 메모리를 더 확보할 수 있지 않을까?'라는 의문이 들 수 있습니다.
이는 작은 수에서는 합리적일 수 있지만, 늘 그렇지는 않습니다.

## 값을 저장하는 방식 vs 값의 주소를 저장하는 방식

```js
var obj = {
  x: "매우 큰 용량을 차지하는 문자열!",
  arr: ["매우 큰 용량을 차지하는 문자열!", 4],
};
```

"매우 큰 용량을 차지하는 문자열!"이라는 값을 한 메모리에 저장할 수 있다고 가정해봅시다.
두 값은 우리가 눈으로 보기에는 같지만 컴퓨터는 같은지 모릅니다.
컴퓨터는 자신이 이해할 수 있는 이진법 숫자들로 전환한 다음에 메모리에 저장합니다.

![컴퓨터 메모리 이미지 18](/assets/blog/data-type/19.png)

이진법은 너무 길어서 16진법으로 표기한 그림입니다.
두 메모리에 같은 값을 넣었지만 아직 비교를 위한 비용은 발생하지 않았습니다.

```js
obj.x === obj.arr[0];
```

나중에 비교를 하게 되면 컴퓨터는 두 값을 이진법인 상태에서 하나하나 비교합니다.
이렇게 비교하는 것만으로 상당한 성능 저하를 야기합니다.
이런 문자열을 무수히 많은 메모리에 저장한다면 비교할 때마다 시간이 굉장히 오래 걸릴 것입니다.

![컴퓨터 메모리 이미지 19](/assets/blog/data-type/20.png)

반면 처음에 저장할 때 비어있는 다른 메모리에 저장하고 주소를 저장하는 방식을 따르게 되면 문자열을 새로 만들어서 입력할 때마다 기존에 저장된 데이터가 있는지 하나씩 비교해야 하는 단점이 있습니다.
하지만 한 번 동일하다고 판단되면 이후 비교 과정을 몇 번을 수행하든 전혀 비용이 발생하지 않습니다.
같은 주소를 보고 있으므로 같은 값일 수밖에 없으니까요.

![컴퓨터 메모리 이미지 20](/assets/blog/data-type/21.png)

![값을 직접 저장할 때와 주소를 저장할 때의 메모리를 차지하는 계산을 비교한 사진](/assets/blog/data-type/22.png)

값을 주소에 저장하게 되면 메모리도 훨씬 덜 차지합니다.
30 바이트가 넘는 문자열 x개가 있다고 가정한다면 값을 직접 저장하면 30 \* x byte가 필요한 반면 값의 주소를 저장하면 30 + x byte로 충분합니다.

따라서 값을 직접 저장하는 방식은 데이터 할당 시에는 빠르지만 비교 비용이 많고 메모리 낭비가 심합니다.

반면에 주소를 저장하는 방식은 할당 시에는 느리지만 비교 비용이 들지 않고 메모리 낭비를 최소화할 수 있습니다.

값의 주소를 저장하는 방식이 손해보다 얻는 이익이 큰 셈입니다.

비교 비용이 들지 않는다는 것은 같은 값은 오직 하나만 존재한다는 뜻이고 불변값을 의미합니다.
그렇기 때문에 기본형 데이터를 불변값이라고 합니다.

## 변수 복사

![변수 복사에 대한 메모리를 설명하는 사진1](/assets/blog/data-type/23.png)

기본형 데이터가 할당하는 방식으로 a가 선언되고 값이 할당됩니다.
b에 a를 할당했으므로 한 메모리에 b를 선언하고 같은 값을 할당합니다.
obj1도 참조형 데이터가 할당하는 방식으로 선언되고 할당됩니다.
obj2에 obj1을 넣었으니 obj1의 값을 obj2의 값으로 할당합니다.

```js
b = 15;
```

![변수 복사에 대한 메모리를 설명하는 사진2](/assets/blog/data-type/24.png)

b에 15를 넣어주면 컴퓨터는 빈 메모리에 15를 할당하고 b에 주소를 할당합니다.

```js
obj.c = 20;
```

![변수 복사에 대한 메모리를 설명하는 사진3](/assets/blog/data-type/25.png)

obj.c에 20을 할당하면 컴퓨터는 빈 메모리에 20을 할당하고 obj2의 값이 가르키는 주소로 이동한 뒤 해당 메모리가 확보한 메모리로 이동하여 c 프로퍼티의 값에 주소를 할당합니다.

![변수 복사에 대한 메모리를 설명하는 사진4](/assets/blog/data-type/26.png)

결과를 보면 기본형은 값이 바뀐 반면에 참조형은 값이 바뀌지 않습니다.
이로 인해 복사한 객체의 값을 바꾸면 원본 객체의 값이 같이 바뀌게 되는 것입니다.
